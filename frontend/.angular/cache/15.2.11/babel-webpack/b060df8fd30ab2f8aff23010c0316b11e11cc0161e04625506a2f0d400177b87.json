{"ast":null,"code":"import _asyncToGenerator from \"/Users/marieklinaeva/github/ck-board/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\n\n/**\n * EXIF tag standard reference\n *\n * Tag Name: Orientation\n * Tag ID: 0x0112\n * Writable: int16u\n * Group: IFD0\n * Values:\n 1 = Horizontal (normal)\n 2 = Mirror horizontal\n 3 = Rotate 180\n 4 = Mirror vertical\n 5 = Mirror horizontal and rotate 270 CW\n 6 = Rotate 90 CW\n 7 = Mirror horizontal and rotate 90 CW\n 8 = Rotate 270 CW\n */\nvar DOC_ORIENTATION;\n(function (DOC_ORIENTATION) {\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Up\"] = 1] = \"Up\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Down\"] = 3] = \"Down\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Right\"] = 6] = \"Right\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Left\"] = 8] = \"Left\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"UpMirrored\"] = 2] = \"UpMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"DownMirrored\"] = 4] = \"DownMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"LeftMirrored\"] = 5] = \"LeftMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"RightMirrored\"] = 7] = \"RightMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Default\"] = 0] = \"Default\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"NotJpeg\"] = -1] = \"NotJpeg\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"NotDefined\"] = -2] = \"NotDefined\";\n})(DOC_ORIENTATION || (DOC_ORIENTATION = {}));\nvar _a;\nclass ImageCompress {}\n_a = ImageCompress;\nImageCompress.getOrientation = file => new Promise((resolve, reject) => {\n  try {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const view = new DataView(reader.result);\n      if (!view.byteLength) {\n        return resolve(DOC_ORIENTATION.NotDefined);\n      }\n      if (view.getUint16(0, false) !== 0xffd8) {\n        return resolve(DOC_ORIENTATION.NotDefined);\n      }\n      const length = view.byteLength;\n      let offset = 2;\n      while (offset < length) {\n        const marker = view.getUint16(offset, false);\n        offset += 2;\n        if (marker === 0xffe1) {\n          if (view.getUint32(offset += 2, false) !== 0x45786966) {\n            return resolve(DOC_ORIENTATION.NotJpeg);\n          }\n          const little = view.getUint16(offset += 6, false) === 0x4949;\n          offset += view.getUint32(offset + 4, little);\n          const tags = view.getUint16(offset, little);\n          offset += 2;\n          for (let i = 0; i < tags; i++) {\n            if (view.getUint16(offset + i * 12, little) === 0x0112) {\n              return resolve(view.getUint16(offset + i * 12 + 8, little));\n            }\n          }\n        } else if ((marker & 0xff00) !== 0xff00) {\n          break;\n        } else {\n          offset += view.getUint16(offset, false);\n        }\n      }\n      return resolve(DOC_ORIENTATION.NotJpeg);\n    };\n    reader.readAsArrayBuffer(file);\n  } catch (e) {\n    return reject(DOC_ORIENTATION.Default);\n  }\n});\nImageCompress.uploadFile = (render, multiple = true, rejectOnCancel = false) => new Promise(function (resolve, reject) {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);\n  Promise.resolve(isSafari || isIOS).then(onlyNative => {\n    if (onlyNative) {\n      return ImageCompress.generateUploadInputNative(window.document, multiple, rejectOnCancel);\n    } else {\n      return ImageCompress.generateUploadInputRenderer(render, multiple, rejectOnCancel);\n    }\n  }).then(filesList => {\n    const files = filesList ? Array.from(filesList) : [];\n    const orientationPromises = files.map(file => ImageCompress.getOrientation(file));\n    const readerPromises = files.map(file => ImageCompress.fileToDataURL(file));\n    let orientationsResult = [];\n    Promise.all(orientationPromises).then(orientations => {\n      orientationsResult = orientations;\n      return Promise.all(readerPromises);\n    }).then(readerResult => {\n      const resultArray = readerResult.map((parsedFile, index) => ({\n        image: parsedFile.dataUrl,\n        orientation: orientationsResult[index],\n        fileName: parsedFile.fileName\n      }));\n      if (multiple) {\n        resolve(resultArray);\n      } else {\n        resolve(resultArray[0]);\n      }\n    });\n  }).catch(err => reject(err));\n});\nImageCompress.fileToDataURL = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      //myReader.onloadend = (progressEvent: ProgressEvent<FileReader>)\n      resolve({\n        dataUrl: e.target.result,\n        fileName: file.name\n      });\n    };\n    try {\n      reader.readAsDataURL(file);\n    } catch (e) {\n      reject(`ngx-image-compress - probably no file have been selected: ${e}`);\n    }\n  });\n};\nImageCompress.generateUploadInputRenderer = (render, multiple = true, rejectOnCancel = false) => {\n  let lock = false;\n  return new Promise((resolve, reject) => {\n    const inputElement = render.createElement('input');\n    render.setStyle(inputElement, 'display', 'none');\n    render.setProperty(inputElement, 'type', 'file');\n    render.setProperty(inputElement, 'accept', 'image/*');\n    if (multiple) {\n      render.setProperty(inputElement, 'multiple', 'true');\n    }\n    render.listen(inputElement, 'click', $event => {\n      $event.target.value = '';\n    });\n    render.listen(inputElement, 'change', $event => {\n      lock = true;\n      const files = $event.target.files;\n      resolve(files);\n    });\n    if (rejectOnCancel) {\n      window.addEventListener('focus', () => {\n        setTimeout(() => {\n          if (!lock) {\n            reject(new Error('file upload on blur - no file selected'));\n          }\n        }, 300);\n      }, {\n        once: true\n      });\n    }\n    inputElement.click();\n  });\n};\nImageCompress.generateUploadInputNative = (documentNativeApi, multiple = true, rejectOnCancel = false) => {\n  let lock = false;\n  return new Promise((resolve, reject) => {\n    const inputElement = documentNativeApi.createElement('input');\n    inputElement.id = 'upload-input' + new Date();\n    inputElement.style.display = 'none';\n    inputElement.setAttribute('type', 'file');\n    inputElement.setAttribute('accept', 'image/*');\n    if (multiple) {\n      inputElement.setAttribute('multiple', 'true');\n    }\n    documentNativeApi.body.appendChild(inputElement);\n    inputElement.addEventListener('change', () => {\n      lock = true;\n      resolve(inputElement.files);\n      documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n    }, {\n      once: true\n    });\n    if (rejectOnCancel) {\n      window.addEventListener('focus', () => {\n        setTimeout(() => {\n          if (!lock && documentNativeApi.getElementById(inputElement.id)) {\n            reject(new Error('file upload on blur - no file selected'));\n            documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n          }\n        }, 300);\n      }, {\n        once: true\n      });\n    }\n    // open file select box\n    inputElement.click();\n  });\n};\nImageCompress.compress = (imageDataUrlSource, orientation, render, ratio = 50, quality = 50, maxwidth = 0, maxheight = 0) => new Promise(function (resolve, reject) {\n  quality = quality / 100;\n  ratio = ratio / 100;\n  const sourceImage = new Image();\n  // important for safari: we need to wait for onload event\n  sourceImage.onload = () => {\n    const canvas = render.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      return reject(`No canvas context available`);\n    }\n    let w = sourceImage.naturalWidth;\n    let h = sourceImage.naturalHeight;\n    if (!CSS.supports('image-orientation', 'from-image')) {\n      if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n        const t = w;\n        w = h;\n        h = t;\n      }\n    }\n    let xratio = maxwidth ? maxwidth / w : 1;\n    let yratio = maxheight ? maxheight / h : 1;\n    ratio = Math.min(ratio, xratio, yratio);\n    canvas.width = w * ratio;\n    canvas.height = h * ratio;\n    const TO_RADIANS = Math.PI / 180;\n    if (CSS.supports('image-orientation', 'from-image') || orientation === DOC_ORIENTATION.Up) {\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n    } else if (orientation === DOC_ORIENTATION.Right) {\n      ctx.save();\n      ctx.rotate(90 * TO_RADIANS);\n      ctx.translate(0, -canvas.width);\n      ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n      ctx.restore();\n    } else if (orientation === DOC_ORIENTATION.Left) {\n      ctx.save();\n      ctx.rotate(-90 * TO_RADIANS);\n      ctx.translate(-canvas.width, 0);\n      ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n      ctx.restore();\n    } else if (orientation === DOC_ORIENTATION.Down) {\n      ctx.save();\n      ctx.rotate(180 * TO_RADIANS);\n      ctx.translate(-canvas.width, -canvas.height);\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n      ctx.restore();\n    } else {\n      // no orientation value found - same as default UP\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n    }\n    const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5);\n    // TODO test on mime\n    const result = canvas.toDataURL(mime, quality);\n    resolve(result);\n  };\n  sourceImage.onerror = e => reject(e);\n  sourceImage.src = imageDataUrlSource;\n});\nImageCompress.byteCount = imgString => encodeURI(imgString).split(/%..|./).length - 1;\nImageCompress.getImageMaxSize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (maxSizeMb, debugMode, render, rejectOnCancel = false) {\n    const MAX_TRIES = 10;\n    const bytesToMB = bytes => (bytes / 1024 / 1024).toFixed(2);\n    if (debugMode) {\n      console.debug('NgxImageCompress - Opening upload window');\n    }\n    let myFile = yield ImageCompress.uploadFile(render, false, rejectOnCancel);\n    let compressedFile;\n    for (let i = 0; i < MAX_TRIES; i++) {\n      const previousSize = ImageCompress.byteCount(myFile.image);\n      compressedFile = yield ImageCompress.compress(myFile.image, myFile.orientation, render, 50, 100);\n      const newSize = ImageCompress.byteCount(compressedFile);\n      console.debug('NgxImageCompress -', 'Compression from', bytesToMB(previousSize), 'MB to', bytesToMB(newSize), 'MB');\n      if (newSize >= previousSize) {\n        if (i === 0) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't be reduced at all - returning the original\", bytesToMB(previousSize), 'MB large');\n          }\n          throw myFile.image;\n        } else {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't be reduced more - returning the best we can, which is \", bytesToMB(previousSize), 'MB large');\n          }\n          throw myFile.image;\n        }\n      } else {\n        if (newSize < maxSizeMb * 1024 * 1024) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', 'Here your file', bytesToMB(newSize), 'MB large');\n          }\n          return compressedFile;\n        } else if (i === 9) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't reach the desired size after\", MAX_TRIES, 'tries. Returning file ', bytesToMB(previousSize), 'MB large');\n          }\n          throw myFile.image;\n        }\n      }\n      if (debugMode) {\n        console.debug('NgxImageCompress -', 'Reached', bytesToMB(newSize), 'MB large. Trying another time after', i + 1, 'times');\n      }\n      myFile.image = compressedFile;\n    }\n    if (debugMode) {\n      console.debug('NgxImageCompress - Unexpected error');\n    }\n    throw '';\n  });\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nclass NgxImageCompressService {\n  constructor(rendererFactory) {\n    this.DOC_ORIENTATION = DOC_ORIENTATION;\n    this.render = rendererFactory.createRenderer(null, null);\n  }\n  /**\n   * helper to evaluate the compression rate\n   * @param imgString the image in base64 string format\n   */\n  byteCount(image) {\n    return ImageCompress.byteCount(image);\n  }\n  /**\n   * Get the correct Orientation value from image tags\n   */\n  getOrientation(file) {\n    return ImageCompress.getOrientation(file);\n  }\n  /**\n   * return a promise with the new image data and image orientation\n   * Nothing happen if no file have been selected\n   */\n  uploadFile() {\n    return ImageCompress.uploadFile(this.render, false);\n  }\n  /**\n   * return a promise with an array of image data and image orientation\n   * Nothing happen if no files have been selected\n   */\n  uploadMultipleFiles() {\n    return ImageCompress.uploadFile(this.render, true);\n  }\n  /**\n   * return a promise with the new image data and image orientation\n   * the promise will reject if no file have been selected\n   */\n  uploadFileOrReject() {\n    return ImageCompress.uploadFile(this.render, false, true);\n  }\n  /**\n   * return a promise with an array of image data and image orientation\n   * the promise will reject if no files have been selected\n   */\n  uploadMultipleFilesOrReject() {\n    return ImageCompress.uploadFile(this.render, true, true);\n  }\n  /**\n  * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method\n  *\n  *\n  | Parameter   | Type   | Description                                                                       |\n  | ----------- | ------ | --------------------------------------------------------------------------------- |\n  | image       | string | DataUrl (string) representing the image                                           |\n  | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |\n  | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |\n  | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |\n  | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |\n  | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |\n  */\n  compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {\n    return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);\n  }\n  /**\n   * Most simple function to use here.\n   * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*\n   * If the size can't be reached, the best that can be reached will be returned in promise *rejection*\n   * Put debugMode to true if you have some trouble to print some help using console.debug\n   */\n  uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {\n    return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel);\n  }\n}\nNgxImageCompressService.ɵfac = function NgxImageCompressService_Factory(t) {\n  return new (t || NgxImageCompressService)(i0.ɵɵinject(i0.RendererFactory2));\n};\nNgxImageCompressService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxImageCompressService,\n  factory: NgxImageCompressService.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxImageCompressService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.RendererFactory2\n    }];\n  }, null);\n})();\n\n/*\n * Public API Surface of ngx-image-compress\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DOC_ORIENTATION, NgxImageCompressService };","map":{"version":3,"names":["i0","Injectable","DOC_ORIENTATION","_a","ImageCompress","getOrientation","file","Promise","resolve","reject","reader","FileReader","onload","view","DataView","result","byteLength","NotDefined","getUint16","length","offset","marker","getUint32","NotJpeg","little","tags","i","readAsArrayBuffer","e","Default","uploadFile","render","multiple","rejectOnCancel","isSafari","test","navigator","userAgent","isIOS","then","onlyNative","generateUploadInputNative","window","document","generateUploadInputRenderer","filesList","files","Array","from","orientationPromises","map","readerPromises","fileToDataURL","orientationsResult","all","orientations","readerResult","resultArray","parsedFile","index","image","dataUrl","orientation","fileName","catch","err","target","name","readAsDataURL","lock","inputElement","createElement","setStyle","setProperty","listen","$event","value","addEventListener","setTimeout","Error","once","click","documentNativeApi","id","Date","style","display","setAttribute","body","appendChild","removeChild","getElementById","compress","imageDataUrlSource","ratio","quality","maxwidth","maxheight","sourceImage","Image","canvas","ctx","getContext","w","naturalWidth","h","naturalHeight","CSS","supports","Right","Left","t","xratio","yratio","Math","min","width","height","TO_RADIANS","PI","Up","drawImage","save","rotate","translate","restore","Down","mime","substr","split","toDataURL","onerror","src","byteCount","imgString","encodeURI","getImageMaxSize","maxSizeMb","debugMode","MAX_TRIES","bytesToMB","bytes","toFixed","console","debug","myFile","compressedFile","previousSize","newSize","NgxImageCompressService","constructor","rendererFactory","createRenderer","uploadMultipleFiles","uploadFileOrReject","uploadMultipleFilesOrReject","compressFile","maxWidth","maxHeight","uploadAndGetImageWithMaxSize","ɵfac","RendererFactory2","ɵprov","type","args","providedIn"],"sources":["/Users/marieklinaeva/github/ck-board/frontend/node_modules/ngx-image-compress/fesm2020/ngx-image-compress.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\n\n/**\n * EXIF tag standard reference\n *\n * Tag Name: Orientation\n * Tag ID: 0x0112\n * Writable: int16u\n * Group: IFD0\n * Values:\n 1 = Horizontal (normal)\n 2 = Mirror horizontal\n 3 = Rotate 180\n 4 = Mirror vertical\n 5 = Mirror horizontal and rotate 270 CW\n 6 = Rotate 90 CW\n 7 = Mirror horizontal and rotate 90 CW\n 8 = Rotate 270 CW\n */\nvar DOC_ORIENTATION;\n(function (DOC_ORIENTATION) {\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Up\"] = 1] = \"Up\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Down\"] = 3] = \"Down\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Right\"] = 6] = \"Right\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Left\"] = 8] = \"Left\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"UpMirrored\"] = 2] = \"UpMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"DownMirrored\"] = 4] = \"DownMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"LeftMirrored\"] = 5] = \"LeftMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"RightMirrored\"] = 7] = \"RightMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Default\"] = 0] = \"Default\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"NotJpeg\"] = -1] = \"NotJpeg\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"NotDefined\"] = -2] = \"NotDefined\";\n})(DOC_ORIENTATION || (DOC_ORIENTATION = {}));\n\nvar _a;\nclass ImageCompress {\n}\n_a = ImageCompress;\nImageCompress.getOrientation = (file) => new Promise((resolve, reject) => {\n    try {\n        const reader = new FileReader();\n        reader.onload = () => {\n            const view = new DataView(reader.result);\n            if (!view.byteLength) {\n                return resolve(DOC_ORIENTATION.NotDefined);\n            }\n            if (view.getUint16(0, false) !== 0xffd8) {\n                return resolve(DOC_ORIENTATION.NotDefined);\n            }\n            const length = view.byteLength;\n            let offset = 2;\n            while (offset < length) {\n                const marker = view.getUint16(offset, false);\n                offset += 2;\n                if (marker === 0xffe1) {\n                    if (view.getUint32((offset += 2), false) !== 0x45786966) {\n                        return resolve(DOC_ORIENTATION.NotJpeg);\n                    }\n                    const little = view.getUint16((offset += 6), false) === 0x4949;\n                    offset += view.getUint32(offset + 4, little);\n                    const tags = view.getUint16(offset, little);\n                    offset += 2;\n                    for (let i = 0; i < tags; i++) {\n                        if (view.getUint16(offset + i * 12, little) === 0x0112) {\n                            return resolve(view.getUint16(offset + i * 12 + 8, little));\n                        }\n                    }\n                }\n                else if ((marker & 0xff00) !== 0xff00) {\n                    break;\n                }\n                else {\n                    offset += view.getUint16(offset, false);\n                }\n            }\n            return resolve(DOC_ORIENTATION.NotJpeg);\n        };\n        reader.readAsArrayBuffer(file);\n    }\n    catch (e) {\n        return reject(DOC_ORIENTATION.Default);\n    }\n});\nImageCompress.uploadFile = (render, multiple = true, rejectOnCancel = false) => new Promise(function (resolve, reject) {\n    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);\n    Promise.resolve(isSafari || isIOS)\n        .then(onlyNative => {\n        if (onlyNative) {\n            return ImageCompress.generateUploadInputNative(window.document, multiple, rejectOnCancel);\n        }\n        else {\n            return ImageCompress.generateUploadInputRenderer(render, multiple, rejectOnCancel);\n        }\n    })\n        .then((filesList) => {\n        const files = filesList ? Array.from(filesList) : [];\n        const orientationPromises = files.map(file => ImageCompress.getOrientation(file));\n        const readerPromises = files.map(file => ImageCompress.fileToDataURL(file));\n        let orientationsResult = [];\n        Promise.all(orientationPromises)\n            .then((orientations) => {\n            orientationsResult = orientations;\n            return Promise.all(readerPromises);\n        })\n            .then(readerResult => {\n            const resultArray = readerResult.map((parsedFile, index) => ({\n                image: parsedFile.dataUrl,\n                orientation: orientationsResult[index],\n                fileName: parsedFile.fileName,\n            }));\n            if (multiple) {\n                resolve(resultArray);\n            }\n            else {\n                resolve(resultArray[0]);\n            }\n        });\n    })\n        .catch(err => reject(err));\n});\nImageCompress.fileToDataURL = (file) => {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            //myReader.onloadend = (progressEvent: ProgressEvent<FileReader>)\n            resolve({ dataUrl: e.target.result, fileName: file.name });\n        };\n        try {\n            reader.readAsDataURL(file);\n        }\n        catch (e) {\n            reject(`ngx-image-compress - probably no file have been selected: ${e}`);\n        }\n    });\n};\nImageCompress.generateUploadInputRenderer = (render, multiple = true, rejectOnCancel = false) => {\n    let lock = false;\n    return new Promise((resolve, reject) => {\n        const inputElement = render.createElement('input');\n        render.setStyle(inputElement, 'display', 'none');\n        render.setProperty(inputElement, 'type', 'file');\n        render.setProperty(inputElement, 'accept', 'image/*');\n        if (multiple) {\n            render.setProperty(inputElement, 'multiple', 'true');\n        }\n        render.listen(inputElement, 'click', ($event) => {\n            $event.target.value = '';\n        });\n        render.listen(inputElement, 'change', $event => {\n            lock = true;\n            const files = $event.target.files;\n            resolve(files);\n        });\n        if (rejectOnCancel) {\n            window.addEventListener('focus', () => {\n                setTimeout(() => {\n                    if (!lock) {\n                        reject(new Error('file upload on blur - no file selected'));\n                    }\n                }, 300);\n            }, { once: true });\n        }\n        inputElement.click();\n    });\n};\nImageCompress.generateUploadInputNative = (documentNativeApi, multiple = true, rejectOnCancel = false) => {\n    let lock = false;\n    return new Promise((resolve, reject) => {\n        const inputElement = documentNativeApi.createElement('input');\n        inputElement.id = 'upload-input' + new Date();\n        inputElement.style.display = 'none';\n        inputElement.setAttribute('type', 'file');\n        inputElement.setAttribute('accept', 'image/*');\n        if (multiple) {\n            inputElement.setAttribute('multiple', 'true');\n        }\n        documentNativeApi.body.appendChild(inputElement);\n        inputElement.addEventListener('change', () => {\n            lock = true;\n            resolve(inputElement.files);\n            documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n        }, { once: true });\n        if (rejectOnCancel) {\n            window.addEventListener('focus', () => {\n                setTimeout(() => {\n                    if (!lock && documentNativeApi.getElementById(inputElement.id)) {\n                        reject(new Error('file upload on blur - no file selected'));\n                        documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n                    }\n                }, 300);\n            }, { once: true });\n        }\n        // open file select box\n        inputElement.click();\n    });\n};\nImageCompress.compress = (imageDataUrlSource, orientation, render, ratio = 50, quality = 50, maxwidth = 0, maxheight = 0) => new Promise(function (resolve, reject) {\n    quality = quality / 100;\n    ratio = ratio / 100;\n    const sourceImage = new Image();\n    // important for safari: we need to wait for onload event\n    sourceImage.onload = () => {\n        const canvas = render.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return reject(`No canvas context available`);\n        }\n        let w = sourceImage.naturalWidth;\n        let h = sourceImage.naturalHeight;\n        if (!CSS.supports('image-orientation', 'from-image')) {\n            if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n                const t = w;\n                w = h;\n                h = t;\n            }\n        }\n        let xratio = maxwidth ? maxwidth / w : 1;\n        let yratio = maxheight ? maxheight / h : 1;\n        ratio = Math.min(ratio, xratio, yratio);\n        canvas.width = w * ratio;\n        canvas.height = h * ratio;\n        const TO_RADIANS = Math.PI / 180;\n        if (CSS.supports('image-orientation', 'from-image') || orientation === DOC_ORIENTATION.Up) {\n            ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n        }\n        else if (orientation === DOC_ORIENTATION.Right) {\n            ctx.save();\n            ctx.rotate(90 * TO_RADIANS);\n            ctx.translate(0, -canvas.width);\n            ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n            ctx.restore();\n        }\n        else if (orientation === DOC_ORIENTATION.Left) {\n            ctx.save();\n            ctx.rotate(-90 * TO_RADIANS);\n            ctx.translate(-canvas.width, 0);\n            ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n            ctx.restore();\n        }\n        else if (orientation === DOC_ORIENTATION.Down) {\n            ctx.save();\n            ctx.rotate(180 * TO_RADIANS);\n            ctx.translate(-canvas.width, -canvas.height);\n            ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n            ctx.restore();\n        }\n        else {\n            // no orientation value found - same as default UP\n            ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n        }\n        const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5);\n        // TODO test on mime\n        const result = canvas.toDataURL(mime, quality);\n        resolve(result);\n    };\n    sourceImage.onerror = e => reject(e);\n    sourceImage.src = imageDataUrlSource;\n});\nImageCompress.byteCount = (imgString) => encodeURI(imgString).split(/%..|./).length - 1;\nImageCompress.getImageMaxSize = async (maxSizeMb, debugMode, render, rejectOnCancel = false) => {\n    const MAX_TRIES = 10;\n    const bytesToMB = (bytes) => (bytes / 1024 / 1024).toFixed(2);\n    if (debugMode) {\n        console.debug('NgxImageCompress - Opening upload window');\n    }\n    let myFile = (await ImageCompress.uploadFile(render, false, rejectOnCancel));\n    let compressedFile;\n    for (let i = 0; i < MAX_TRIES; i++) {\n        const previousSize = ImageCompress.byteCount(myFile.image);\n        compressedFile = await ImageCompress.compress(myFile.image, myFile.orientation, render, 50, 100);\n        const newSize = ImageCompress.byteCount(compressedFile);\n        console.debug('NgxImageCompress -', 'Compression from', bytesToMB(previousSize), 'MB to', bytesToMB(newSize), 'MB');\n        if (newSize >= previousSize) {\n            if (i === 0) {\n                if (debugMode) {\n                    console.debug('NgxImageCompress -', \"File can't be reduced at all - returning the original\", bytesToMB(previousSize), 'MB large');\n                }\n                throw myFile.image;\n            }\n            else {\n                if (debugMode) {\n                    console.debug('NgxImageCompress -', \"File can't be reduced more - returning the best we can, which is \", bytesToMB(previousSize), 'MB large');\n                }\n                throw myFile.image;\n            }\n        }\n        else {\n            if (newSize < maxSizeMb * 1024 * 1024) {\n                if (debugMode) {\n                    console.debug('NgxImageCompress -', 'Here your file', bytesToMB(newSize), 'MB large');\n                }\n                return compressedFile;\n            }\n            else if (i === 9) {\n                if (debugMode) {\n                    console.debug('NgxImageCompress -', \"File can't reach the desired size after\", MAX_TRIES, 'tries. Returning file ', bytesToMB(previousSize), 'MB large');\n                }\n                throw myFile.image;\n            }\n        }\n        if (debugMode) {\n            console.debug('NgxImageCompress -', 'Reached', bytesToMB(newSize), 'MB large. Trying another time after', i + 1, 'times');\n        }\n        myFile.image = compressedFile;\n    }\n    if (debugMode) {\n        console.debug('NgxImageCompress - Unexpected error');\n    }\n    throw '';\n};\n\nclass NgxImageCompressService {\n    constructor(rendererFactory) {\n        this.DOC_ORIENTATION = DOC_ORIENTATION;\n        this.render = rendererFactory.createRenderer(null, null);\n    }\n    /**\n     * helper to evaluate the compression rate\n     * @param imgString the image in base64 string format\n     */\n    byteCount(image) {\n        return ImageCompress.byteCount(image);\n    }\n    /**\n     * Get the correct Orientation value from image tags\n     */\n    getOrientation(file) {\n        return ImageCompress.getOrientation(file);\n    }\n    /**\n     * return a promise with the new image data and image orientation\n     * Nothing happen if no file have been selected\n     */\n    uploadFile() {\n        return ImageCompress.uploadFile(this.render, false);\n    }\n    /**\n     * return a promise with an array of image data and image orientation\n     * Nothing happen if no files have been selected\n     */\n    uploadMultipleFiles() {\n        return ImageCompress.uploadFile(this.render, true);\n    }\n    /**\n     * return a promise with the new image data and image orientation\n     * the promise will reject if no file have been selected\n     */\n    uploadFileOrReject() {\n        return ImageCompress.uploadFile(this.render, false, true);\n    }\n    /**\n     * return a promise with an array of image data and image orientation\n     * the promise will reject if no files have been selected\n     */\n    uploadMultipleFilesOrReject() {\n        return ImageCompress.uploadFile(this.render, true, true);\n    }\n    /**\n   * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method\n   *\n   *\n   | Parameter   | Type   | Description                                                                       |\n   | ----------- | ------ | --------------------------------------------------------------------------------- |\n   | image       | string | DataUrl (string) representing the image                                           |\n   | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |\n   | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |\n   | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |\n   | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |\n   | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |\n   */\n    compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {\n        return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);\n    }\n    /**\n     * Most simple function to use here.\n     * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*\n     * If the size can't be reached, the best that can be reached will be returned in promise *rejection*\n     * Put debugMode to true if you have some trouble to print some help using console.debug\n     */\n    uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {\n        return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel);\n    }\n}\nNgxImageCompressService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCompressService, deps: [{ token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxImageCompressService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCompressService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCompressService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.RendererFactory2 }]; } });\n\n/*\n * Public API Surface of ngx-image-compress\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DOC_ORIENTATION, NgxImageCompressService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}